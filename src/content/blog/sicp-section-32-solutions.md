---
title: "SICP Section 3.2 solutions"
description: "SICP exercises 3.9 - 3.11 - Section 3.2 solutions"
pubDate: 2017-03-10
tags: ["sicp", "computer-science", "scheme", "programming", "functional-programming"]
---


In this exercise, we are asked to show the environment structure when evaluating the two provided procedures for computing factorials.

##### Recursive solution

The recursive code is given as follows:-

```scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

The environment structures creating by evaluating `(factorial 6)` is as follows:-

<center>
<img src="/images/Ex3_9_Recursive.svg" alt="Environment structure for recursive case"/>
</center>

##### Iterative solution

The iterative code is given as follows:-

```scheme
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product 
                   counter 
                   max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

<center>
<img src="/images/Ex3_9_Iterative.svg" alt="Environment structure for iterative case"/>
</center>

### Exercise 3.10

In this exercise, we are tasked with illustrating the environment model for the given `make-withdraw` procedure as follows:-

```scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance 
                       (- balance amount))
                 balance)
          "Insufficient funds"))))
```

To understand what happens, let us desugar the `let` expression:-

```scheme
(define (make-withdraw initial-amount)
  ((lambda (balance)
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance 
                       (- balance amount))
                 balance)
                 "Insufficient funds")))
    initial-amount))
```

First, when the initial definition of `make-withdraw` is created, the following environment is set up:-

<center>
<img src="/images/Ex3_10_Step1.svg" alt="After defining make-withdraw" width="500"/>
</center>

Next, calling `(define W1 (make-withdraw 100))` establishes the following environment after evaluating the inner `lambda`:- 

<center>
<img src="/images/Ex3_10_Step2.svg" alt="After defining W1" width="500"/>
</center>

After that, calling `(W1 50)` does the following:- 

<center>
<img src="/images/Ex3_10_Step3.svg" alt="While calling W1" width="500"/>
</center>

This sets `balance` value to 50 based on the definition of `W1` and evaluates to `50` similar to the original function. Finally, defining another function `W2` similar to `W1` ends up with the following:-

<center>
<img src="/images/Ex3_10_Step4.svg" alt="After defining W2" width="555"/>
</center>

As can be seen, both `W1` and `W2` share the same function code but point to a separate environment. Ultimately, this yields in code very similar to what we have before but has an extra `initial-amount` defined which could be used to extend the functionality of the code.


### Exercise 3.11

In this exercise, we are tasked with showing the environment structure generated by the message passing definition version of `make-account` as given below:-

```scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance 
                     (- balance 
                        amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: 
                        MAKE-ACCOUNT" 
                       m))))
  dispatch)
```

With this definition, the following environment is set up by simply storing the definition:-

<center>
<img src="/images/Ex3_11_Step1.svg" alt="After defining make-withdraw"/>
</center>

Next, calling `(define acc (make-account 50))` evaluates the function body and produces the following structure. The newly defined `acc` points to the same location as the inner `dispatch` function:-

<center>
<img src="/images/Ex3_11_Step2.svg" alt="After defining acc"/>
</center>

After that, when we call `((acc 'deposit) 40)` the inner function evaluates to `deposit` in environment *E1* and subsequently, that gets evaluated:-

<center>
<img src="/images/Ex3_11_Step3.svg" alt="After calling deposit"/>
</center>

Evaluating *E2* updates the value of `balance` prints out the updated balance value of *90*. Next, calling `((acc 'withdraw) 60)` does something similar:-

<center>
<img src="/images/Ex3_11_Step4.svg" alt="After calling withdraw"/>
</center>

Evaluating *E3* updates `balance` and outputs `30`.

Finally, calling `(define acc2 (make-account 100))` sets up the following:-

<center>
<img src="/images/Ex3_11_Step5.svg" alt="After defining acc2"/>
</center>

As can be seen, defining `acc2` creates a new sub-environment that tracks its own value of `balance` in local environment. Like before, the code for the sub-functions `deposit`, `withdraw` and `dispatch` are shared but the with pointers back to different environments. 
